<html>

<head>
    <title>ELKS FAQ (russian translation from 20/10/01)</title>
    <base href="http://elks.sf.net/faq/">
    <meta http-equiv="Content-Type" content="text/html; charset=koi8-r">
    <meta name="Author" content="Roman Festchook">
    <meta name="keywords" content="elks faq linux kernel 8086 8088 80286 русская документация PC XT AT линукс ядро UNIX linux-8086">
</head>

<body>
    <h1>ELKS FAQ</h1>
      Это список ответов на часто задаваемые вопросы по проекту ELKS, также известному как Linux-8086.
      <p>FAQ поддерживается Alistair Riddoch, и базируется на оригинале Brian Candler; дополнения отсылайте на
      <a href="mailto:ajr@ecs.soton.ac.uk">ajr@ecs.soton.ac.uk</a>.
      Свежую версию этого документа можно найти на <a href="http://www.elks.ecs.soton.ac.uk/">http://www.elks.ecs.soton.ac.uk/</a>.
      Замечание - ELKS находится на очень ранней стадии разработки и приведенная ниже информация может устареть очень быстро.</p>
      <p>Русский перевод этого документа осуществил Роман Фещук, если у вас есть какие-либо дополнения и уточнения -
      отправляйте их на <a href="mailto:roma@orta.com.ua">roma@orta.com.ua</a>. Свежий перевод ELKS FAQ на русский язык
      можно найти на <a href="http://elks.orta.com.ua/">http://elks.orta.com.ua/</a>. Вашему внимаю предложенна версия
      перевода с последними изменениями от 20/10/01.</p>
      <p>Существует список рассылки ELKS. Что бы подписаться, направьте письмо на
      <a href="mailto:majordomo@vger.rutgers.edu">majordomo@vger.rutgers.edu</a> содержащее слова subscribe linux-8086 в теле письма.<br>
      Текущий архив сообщений этого списка рассылки доступен
      на <a href="http://www.mail-archive.com/linux-8086@vger.rutgers.edu/index.html">http://www.mail-archive.com/linux-8086@vger.rutgers.edu/index.html</a>.<br>
      Замечание - ELKS это не Linux, и список рассылки это не лучшее место для разговоров о Linux (несмотря на название). Лучшим
      решением была бы отправка таких сообщений в специальные новостные группы Linux, такие как comp.os.linux.misc</p>
      
    <h2>Часть 1 - Общие сведения</h2>
	<ul>
	    <li><a href="#1.1">1.1. Что такое ELKS?</a></li>
    	    <li><a href="#1.2">1.2. Чем ELKS отличается от Linux?</a></li>
    	    <li><a href="#1.3">1.3. Существуют ли рабочие дистрибутивы ELKS?</a></li>
    	    <li><a href="#1.4">1.4. Может ли ELKS работать на 8088 процессоре?</a></li>
	</ul>

    <h2>Часть 2 - Компиляция и установка</h2>
	<ul>
    	    <li><a href="#2.1">2.1. Откуда загрузить исходный код?</a></li>
    	    <li><a href="#2.2">2.2. Как скомпилировать ядро?</a></li>
    	    <li><a href="#2.3">2.3. Я получаю сообщение об ошибке говорящее, что файл /usr/include/linux/vm86.h не существует.</a></li>
    	    <li><a href="#2.4">2.4. Как создать 'init' для ELKS?</a></li>
    	    <li><a href="#2.5">2.5. Как создать диск с корневой файловой системой?</a></li>
    	    <li><a href="#2.6">2.6. Что если у меня есть XT с дисководами на 360K?</a></li>
	    <li><a href="#2.7">2.7. Как изменить устройство с корневой файловой системой в загрузочном образе?</a></li>
    	    <li><a href="#2.8">2.8. Как установить ELKS на жесткий диск?</a></li>
    	    <li><a href="#2.9">2.9. Я получаю сообщение об ошибке при компиляции Dev86 под свежими дистрибутивами Linux.</a></li>
    	    <li><a href="#2.10">2.10. Я получаю сообщения об ошибках при компиляции elkscmd.</a></li>
    	    <li><a href="#2.11">2.11. Я получаю предупреждения, компилируя elkscmd.</a></li>
	</ul>
      
    <h2>Часть 3 - Использование ELKS</h2>
	<ul>
    	    <li><a href="#3.1">3.1. Могу я запускать программы скомпилированные bcc из под Linux?</a></li>
            <li><a href="#3.2">3.2. Могу ли я загрузить ELKS из-под DOSEMU?</a></li>
	</ul>
	
    <h2>Часть 4 - Участие в проекте ELKS</h2>
	<ul>
    	    <li><a href="#4.1">4.1. Я могу участвовать в проекте ELKS?</a></li>
    	    <li><a href="#4.2">4.2. Что нужно сделать?</a></li>
    	    <li><a href="#4.3">4.3. Что такое CVS?</a></li>
    	    <li><a href="#4.4">4.4. Я могу использовать CVS без логина?</a></li>
	</ul>

    <hr>
    
    <h2>Часть 1 - Общие сведения</h2>
      
    <h3><a name="1.1">1.1. Что такое ELKS?</a></h3>
	    ELKS это Встраиваимое Подмножество Ядра Linux (ВПЯД - вот как мерзко выглядит это сокращение на русском,
	    со своей стороны oбязуюсь им больше не пользоваться:-) - проект по построению подмножества ядра Linux
	    (обеспечивающего как можно большую функциональность UNIX V7 в ядре) которое может работать на машинах
	    с ограниченным ресурсами процессора и памяти. Основными являются компьютеры с процессорами Intel 8086
	    и в конечном итоге 286 в 16-битном защищенном режиме. Ядро, которое может работать на таких типах
	    оборудования найдет применение во встраиваемых системах, в странах третьего мира, где более мощная
	    техника не является широкодоступной и в разнообразных карманных компьютерах.
	    Дополнительную информацию о целях и текущем статусе проекта вы можете найти на
	    <a href="http://www.elks.ecs.soton.ac.uk/">домашней странице проекта ELKS</a>.
	    Русскоязычная информация о проекте может быть найдена на <a href="http://elks.orta.com.ua/">ELKS
	    - домашняя страница на русском</a>.
    <h3><a name="1.2">1.2. Чем ELKS отличается от Linux?</a></h3>
	ELKS предполагается как подмножество ядра Linux, достаточно небольшое для понимания одним человеком, так что бы его
	можно было использовать как обучающее средство. ELKS находится на очень ранней стадии разработки, и многие вещи
	еще не реализованны, такие как своппинг и разделяемые библиотеки. Теперь пару слов о том что есть, система способна
	загружаться, поддерживать виртуальные консоли, монтировать диск с корневой файловой системой, обеспечивать базовый
	ввод/вывод через параллельные и последовательные порты, обеспечивать некоторые сетевые возможности и запускать
	различные небольшие программы.</p>
    <h3><a name="1.3">1.3. Существуют ли дистрибутивы ELKS?</a></h3>
	Пока что нет. Вам надо используя компьютер с Linux, загрузить исходники, и скомпилировав их получить рабочий код 8086 процессора.
	Загрузочный (boot) и корневой (root) образы дисков поставляются с текущей версией ELKS, но они скорее могут выступать платформой
	для испытания системы, потому что с ними можно сделать не так уж много.
	<a href="mailto:mstrates@linloft.apana.org.au">Michael Strates</a> - доброволец готовящий рабочий дистрибутив системы.
    <h3><a name="1.4">1.4. Может ли ELKS работать на 8088 процессоре?</a></h3>
      Процессор 8088 идентичен 8086, за исключением внешней шины данных, которая у него 8 битная, в отличие от 16 битной у 8086 (кстати,
      за счет этого 8088 процессор медленнее). Потому ELKS будет работать на нем.

    <hr>
    
    <h2>Часть 2 - Компиляция и установка</h2>
      
    <h3><a name="2.1">2.1 Откуда загрузить исходный код?</a></h3>
	Основной сайт <a href="ftp://ftp.ecs.soton.ac.uk/pub/elks/">ftp://ftp.ecs.soton.ac.uk/pub/elks/</a>, домашняя страница Dev86
	<a href="http://www.cix.co.uk/~mayday/">http://www.cix.co.uk/~mayday/</a>, это лучшие места, где можно найти последние версии.<br>
	Другие сайты на которых можно найти ELKS и Dev86:<br>
	<a href="ftp://tsx-11.mit.edu/pub/linux/ALPHA/linux-16/">ftp://tsx-11.mit.edu/pub/linux/ALPHA/linux-16/</a><br>
	<a href="ftp://src.doc.ic.ac.uk/packages/linux/tsx-11-mirror/ALPHA/linux-16/">ftp://src.doc.ic.ac.uk/packages/linux/tsx-11-mirror/ALPHA/linux-16/</a>
    <p>Если вам известны любые другие сайты, или вы сами хотели бы создать подобный сервер свяжитесь с разработчиками.
    Замечание переводчика - многие из этих сайтов могут оказаться недоступными, ни что не вечно под луной:(, но на момент
    перевода они работали.</p>

    <h3><a name="2.2">2.2. Как скомпилировать ядро ELKS?</a></h3>
	Если вы хотите скомпилировать ядро, загрузите dev86/Dev86-0.0.13.4.tar.gz и kernel/elks-0.0.67/elks-0.0.67.tar.gz
	(или более свежие версии) с любого из сайтов указанных выше. Распакуйте Dev86 в каталог /usr/src (или любую другую
	подходящую директорию), и elks в /usr/src/linux-86:
        <pre>
    
	    tar -xvzf Dev86-0.0.13.tar.gz -C /usr/src
    	    tar -xvzf elks-0.0.67.tar.gz -C /usr/src
        </pre>
	Исходные тексты среды разработки будут в /usr/src/linux-86, а ядра в /usr/src/elks. Следующим шагом надо скомпилировать
	утилиты разработчика, которые включают bcc компилятор:
	<pre>
    
    	    cd /usr/src/linux-86
    	    make install
	</pre>
	Теперь, компилируем ядро:
	<pre>
    
    	    cd /usr/src/elks
    	    make config
    	    make dep
    	    make
	</pre>
	Make config работает также как и для стандартного ядра Linux. Конфигурация по умолчанию работает на большинстве систем,
	поэтому не изменяйте опций значение которых вам не понятно. (Если вы уже создавали ядра Linux с помощью gcc, то вы удивитесь
	насколько это быстро :-). Результат - это образ диска с названием "Image", который вы можете скопировать на отформатированную
	дискету и загрузится с нее.
	<pre>
	
    	    dd if=Image of=/dev/fd0
	</pre>
	или
	<pre>
	
	    make disk
	</pre>
	Теперь вы можете загрузится с этого диска, однако вы не сможете сделать ничего без монтирования корневого диска. Вы можете
	использовать файл образа root находящийся в images.zip, или создать свой собственный. Вам нужно использовать bcc для
	компиляции программы 'init' и создать корневую файловую систему minix. Как это сделать объяснено ниже.<br>
            
    <h3><a name="2.3">2.3. Я получаю сообщение об ошибке говорящее, что файл /usr/include/linux/vm86.h не существует</a></h3>
	Отредактируйте /usr/include/sys/vm86.h, и измените
	<pre>
	
	    #include &lt;linux/vm86.h>
	</pre>
	на
	<pre>
	
	    #include &lt;asm/vm86.h>
	</pre>
      
      <h3><a name="2.4">2.4. Как создать 'init' для ELKS?</a></h3>
    Сразу после своей загрузки ядро ELKS запускает /bin/init. Реальная версия 'init' подготовленна для включения в пакете
    tiny-utils на linux.mit.edu. Простые init и login включены в раделе sysutils пакета elkscmd, который распространяется
    с каждым релизом ядра. Недавно код ядра был изменен так что бы загружался /bin/init вместо /bin/sh.
    <p>Для установки init и login скомпилируйте их оба при помощи
    <pre>
    
    	bcc -0 -O -ansi -s init.c -o init
        bcc -0 -O -ansi -s login.c -o login

	-0 указывает генерировать код процессора 8086
	-O включает оптимизацию
	-ansi включает прототипы функций в ansi-стиле (только)
	-s символы скриптов за пределами библиотеки
    </pre>	
    и скопируйте их в каталог /bin на корневом диске. login нуждается в файлах /etc/passwd и  /etc/group, и /bin/sh
    (или другой оболочке определенной в /etc/passwd).</p>
    <p>Начиная с ядра 0.0.56 sash работает и может быть использован как и /bin/sh. Он может быть найден в
    elkscmd.tar.gz. для лучшего результата скопируйте /etc/passwd и /etc/group из стандартного дистрибутива Linux
    на корневой диск так, чтобы ls -l их отображала, и /usr/lib/liberror.txt для сообщений sash об ошибках. Версия
    ash также есть и работает под ELKS, однако она имеет большой размер и не работает на машинах с менее чем 640Кб ОЗУ.</p>
    
    <h3><a name="2.5">2.5. Как создать диск с корневой файловой системой?</a></h3>
	Для большинства образ коневой файловой системы включенный в images.zip лучшее решение, и он может быть
	использован для создания корневой файловой системы так:
        <pre>
    
	    dd if=root of=/dev/fd0 bs=8192
        </pre>  
        или из под DOS можно использовать утилиту RAWRITE.EXE.
	<p>Иначе, вам нужно создать minix дискету содержащую необходимый джентельменский набор. Этот набор включает в
	себя прграммы init, login и sh в /bin/, а также passwd и group файлы в /etc/, равно как и три tty для init
	в каталоге /dev/. Замечание: /dev/tty отличаются от нормальных в Linux которые используют (5,0).
    <pre>

      	mkdir /usr/src/root86         # создание основной директории
        cd /usr/src/root86
	mkdir dev                     # создание директории устройств
        cd dev			      # создание необходимых устройств
        mknod tty1 c 4 0
	mknod tty2 c 4 1
        mknod tty3 c 4 2
	mknod fd0 b 3 128
				       # копирование необходимых программ
        cd ..
        mkdir bin
        cd bin
	cp path-to-elkscmd-init init
        cp path-to-elkscmd-login login
        cp path-to-elkscmd-sash sh
	cd ..
        mkdir etc
	cd etc
				     # добавление файлов неоходимых login
        cp path-to-skeleton-passwd passwd
	cp path-to-skeleton-group group
        cd ..
        fdformat /dev/fd0H1440            # если дискета неотформатированна
        mkfs.minix -n14 /dev/fd0 1440
	mount -t minix /dev/fd0 /a        # нужен каталог монтирования /a
        cp -pR /usr/src/root86/* /a
        umount /a
    </pre>
	Некоторые дистрибутивы используют /dev/fd0u1440 вместо /dev/fd0H1440. Вы должны удалить пароли из файла passwd
	поскольку они пока не поддерживаются, и быть уверенными, что каждому пользователю в качестве оболочки прописан
	/bin/sh для будущей совместимости.
	<p>Есть вариант, если вы имеете ядро версии от 2.0.x и утилиту mount-2.5k, вы можете использовать loopback
	файловую систему для создания образа диска на вашем жестком диске и потом перенести этот образ на дискету
        <pre>
    
	    dd if=/dev/zero of=root.image bs=18k count=80
	    losetup /dev/loop0 root.image
    	    mkfs -t minix /dev/loop0 1440
    	    mount -t minix /dev/loop0 /a
    	    ...
    	    umount /a
    	    dd if=root.image of=/dev/fd0
	</pre>	
	C ядрами ELKS от 0.0.53 дискеты размеров отличных от 1.44M тоже работают. Просто следуйте приведенным выше инструкциям,
	корректируя только места касающиеся емкости диска. Тем не менее, если вы будете записывать дискеты на 360K на
	дисководах 1.2M и потом попытаетесь загрузить машину с дисководом на 360К, то для вас будут полезны приведенные
	ниже инструкции.
      
      <h3><a name="2.6">2.6. Что если у меня XT с дисководами на 360K?</a></h3>
	Подготовка образов boot и root для запуска на другой машине требует большего труда, особенно если машина на которой
	планируется запускать эти образы имеет дисковод на 360K. 360K дисководы (5.25" DD) имеют 40-дорожек,
	а 1.2MB дисководы (5.25" HD) имееют 80-дорожек. 1.2MB дисковод может читать 360K дискеты, но не может корректно их
	записывать, поскольку он записывает магнитные дорожки половинной длины от стандартных дорожек 360K дисковода.
	<p>Одно из решений это подключение 360K дисковода в качестве второго на вашем Linux PC - на нем вы можете отформатировать
	360K дискету командой
	<pre>
	
	    fdformat /dev/fd1d360
	</pre>
	и создать файловую систему как обычно.</p>
	<p>Иначе вам надо создать образ дискеты и переслать его на ПК имеющий 360K дисковод (например с помощью линк-кабеля),
	потом используя rawrite.exe из-под DOS создать дискету из файла образа.</p>
	
    <h4>Загрузочная дискета</h4>
	Образ диска может быть записан на диск любого размера и после этого с него можно загружаться, все что необходимо
	это переслать образ и использовать rawrite.exe для создания загрузочного диска. Тип дискеты с корневой файловой
	системой теперь определяется автоматически и вам не надо перекомпилировать образ для дисков, имеющих размер
	отличный от 1.44Mb.
    <h4>Дискета с корневой файловой системой</h4>
	Вы можете подготовить 360K образ и на дисководе большей емкости, только в команде mkfs укажите '360' для размера
	файловой системы. После копирования файлов на диск, размонтируйте его и создайте образ диска с помощью комманды:
	<pre>
	
	    dd if=/dev/fd0 of=root.image bs=1k count=360
	</pre>
	Этот образ может быть передан на машину для которой он предназначен и записан на дискету используя как и раньше
	rawrite.exe. Если вы используете loopback файловую систему, то этот шаг не нужен.
    <h4>Ограничения ОЗУ</h4>
	Ядро 0.0.44 ожидает 640K ОЗУ. Однако, если у вас нет 640K проблемы с DEF_INITSEG и DEF_SETUPSEG устранены в последующих версиях.
	Так что не надо ничего изменять.
	
      <h3><a name="2.7">2.7. Как изменить устройство с корневой файловой системой в загрузочном образе?</a></h3>
	Загрузочный образ в версии 0.0.62 скомпилирован для использования второго дисковода в качестве корневой файловой
	системы поскольку функция wait_for_keypress() некорректно работает. Если у вас всего один дисковод, то вы можете
	изменить это используя шестнадцатиричный редактор для изменения номера корневого устройства в образе.
	<p>Если возникает ошибка монтирования корневой файловой системы на устройстве 03c0, загрузите загрузочный образ
	в шестнадцатиричный редактор и найдите c003h где то в начале файла образа и измените это числом 8003h. (c003h это
	03c0 используя обратную запись Intel). Это должно сработать на любой версии, однако не так уж и красиво, поскольку
	местоположение искомой последовательности в образе меняется от версии к версии. <a href="mailto:jose@cnct.com">jose@cnct.com</a>
        сообщает что загрузочный образ в ядре 0.0.62 включает эти два байта по смещению 0adf - oade.

      <h3><a name="2.8">2.8. Как установить ELKS на жесткий диск?</a></h3>
	Начиная с версии 0.0.65 стало возможным установить корневой каталог на жесткий диск и потом создать дискету
	использующую это. Это способ по прежнему имеет некоторые сложности, но он более приемлем, чем корневой каталог
	на дискете.
	<p>Сначала создайте раздел с помощью fdisk. Любая версия fdisk способна сделать это, но в текущих версиях
	корневой диск поддерживает только bd1-bd4 первичные разделы, и если вы имеете первичный раздел DOS, то вы не сможете
	сделать еще один первичный раздел с помощью DOS fdisk.</p>
	<p>Версия fdisk включенная в ELKS 0.0.67 по прежнему имеет нестабильный код, но на моей системе
	вроде бы работает хорошо. После создания раздела, загрузите ELKS с загрузочной и корневой дискет, и создайте файлову
	систему используя mkfs. Стоит воспользоваться fdisk для проверки корректного имени устройства на котором вы хотите
	создать файловую систему. Для создания файловой системы наберите
	<pre>
	
	    mkfs /dev/bd?? size
	</pre>
	где bd?? это раздел, и size это размер раздела в Kb. size не может быть больше 32M. Например для создания файловой
	системы на первом разделе второго жесткого диска, который имеет размер 20M следует набрать:
	<pre>
	
	    mkfs /dev/bdb1 20000
	</pre>
	Теперь подмонтируйте раздел в точку монтирования /mnt набрав:
	<pre>
	
	    mount /dev/bd?? /mnt
	</pre>
	где bd?? это раздел. Корневая директория на новом разделе может выглядеть испорченной, и возможно нельзя будет
	запустить ls в /mnt. Я не знаю почему mkfs создает испорченную файловую систему, но я на ней работаю</p>
	<p> Создайте следующие директории на новом корневом устройстве:
	<pre>
    
            mkdir /mnt/bin
	    mkdir /mnt/dev
            mkdir /mnt/usr
	    mkdir /mnt/usr/lib
    	    mkdir /mnt/mnt
    	    mkdir /mnt/etc
    	    mkdir /mnt/root
    	    mkdir /mnt/home
    	    mkdir /mnt/var
    	    mkdir /mnt/var/run
    	    mkdir /mnt/home/user?
	    ...
	</pre>	
	Теперь скопируйте необходимые файлы. Вам нужно будет много больше файлов даже для скромной системы,
	однако эти одни из самых необходимых и используемых.
	<pre>
      
    	    cp /bin/init /mnt/bin/init
    	    cp /bin/login /mnt/bin/login
    	    cp /bin/getty /mnt/bin/getty
    	    cp /bin/sh /mnt/bin/sh
    	    cp /bin/ls /mnt/bin/ls
    	    cp /bin/pwd /mnt/bin/pwd
    	    cp /bin/mount /mnt/bin/mount
    	    cp /bin/umount /mnt/bin/umount
    	    cp /bin/cp /mnt/bin/cp
	    cp /etc/passwd /mnt/etc/passwd
    	    cp /etc/group /mnt/etc/group
    	    cp /usr/lib/liberror.txt /mnt/usr/lib/liberror.txt
    	    touch /mnt/var/run/utmp
	</pre>	
	Наконец создайте следующие устройства
	<pre>
    
    	    mknod /mnt/dev/tty1 c 4 0
	    mknod /mnt/dev/tty2 c 4 1
    	    mknod /mnt/dev/tty3 c 4 2
    	    mknod /mnt/dev/fd0 b 3 128
    	    mknod /mnt/dev/fd1 b 3 192
    	    mknod /mnt/dev/bda b 3 0
    	    mknod /mnt/dev/bda1 b 3 1
    	    mknod /mnt/dev/bda2 b 3 2
    	    mknod /mnt/dev/bda3 b 3 3
    	    mknod /mnt/dev/bda4 b 3 4
    	    mknod /mnt/dev/bdb b 3 64
    	    mknod /mnt/dev/bdb1 b 3 65
    	    mknod /mnt/dev/bdb2 b 3 66
	    mknod /mnt/dev/bdb3 b 3 67
    	    mknod /mnt/dev/bdb4 b 3 68
	</pre>	
	Теперь размонтируйте новый раздел:
	<pre>
    
    	    umount /dev/bd??
	</pre>
	Вам нужно перекомпилировать ядро с указанием нового устройства с корневой файловой системой. Что бы сделать это отредактируйте
	include/linuxmt/config.h в дереве исходного кода ядра ELKS, и измените CONFIG_ROOTDEV с 0x380 на номер устройства корневого раздела.
	Последние две цифры это номер раздела в шеснадцатиричной системе счисления. Номер может быть найден из
	списка парой строк выше. Например  последний номер для bdb3 это 67 или 43h, итак ROOT_DEV имеет значение 0x343.</p>
	<p>Наберите:
	<pre>
	
	    make disk
	</pre>
	для построения нового загрузочного диска, и загрузите ELKS машину с нового диска. Новый корень должен подмонтироваться,
	правда можеть быть выдано предупреждение, но система запустится как обычно и много быстрее чем с дискеты. Как и раньше
	корневой каталог может быть испорчен, однако должна быть возможность перехода в другие директории, и система в целом
	должна работать нормально.</p>

    <h3><a name="2.9">2.9. Я получаю сообщения об ошибках при компиляции Dev86 под свежими дистрибутивами Linux.</a></h3>
	Есть две проблемы компиляции Dev86 на новых системах, которые известны как проблемы под RedHat 6.0. Во-первых это
	проблема с последними glibc считающими что FILE * не может больше инициализироваться как указатель стандартного ввода/вывода.
	Исправление этой проблемы уже находится в работе. Версия ar включенная в некоторые Linux-системы не может теперь работать
	с bcc-форматом файлов *.o. Новая версия программы ar написана для Dev86 и будет включена в следующий релиз.
	
    <h3><a name="2.10">2.10. Я получаю ошибки при компиляции elkscmd</a></h3>
	Ошибки похожие на текущую могут возникать при компиляции elkscmd, если Dev86 не перекомпилированн корректно при обновлении ядра.
	<pre>
	
	    undefined symbol: _setsid
	    undefined symbol: _fchown
	</pre>
	Это происходит потому, что Dev86 не получил список системных вызовов от текущего исходного кода ядра. Похожая проблема может
	возникнуть, если Dev86 не нашел каталога include ядра, и построил связи к нему в каталоге include bcc.
	<pre>
	
    	    ps.c:2.26: error: cannot find include file linuxmt/sched.h
	</pre>
	Решение обеих проблем состоит в следующем:
	<ul>
	    <li>Проверьте, что в строке в начале файла Makefile которая определяется ELKSSRC определен путь к правильной
		директории в вашей системе.</li>
	    <li>Перекомпилируйте и переинсталируйте libc часть Dev86:
		<pre>
		
    		    make library
		    make install-lib
		    
		</pre>
	    </li>
	    <li>Проверьте, что /usr/bcc/include/linuxmt и /usr/bcc/include/arch ссылаются на elks/include/linuxmt
	    и elks/include/arch соответственно, иначе вы не доберетесь до исходников ядра. Если нет, удалите директории
	    и установите связи вручную:
		<pre>
		
		    rm -rf /usr/bcc/include/linuxmt
		    rm -rf /usr/bcc/include/arch
		    ln -s /usr/src/elks/include/linuxmt /usr/bcc/include
		    ln -s /usr/src/elks/include/arch /usr/bcc/include
		    
		</pre>
	    </li>
	    <li>Проверьте что linux-86/libc/syscall.dat это тоже самое что и elks/arch/i86/kernel/syscall.dat. Если нет
	    то скопируйте версию из каталога ядра и после этого скомпилируйте и инсталируйте снова Dev86:
		<pre>
		
		    cd /usr/src/linux-86
		    cp /usr/src/elks/arch/i86/kernel/syscall.dat libc/syscall/syscall.dat
		    cp /usr/src/elks/arch/i86/kernel/syscall.dat libc/syscall/syscall.dev86
		    make library
		    make install-lib
		</pre>
	    </li>
	</ul>	
	Теперь elkscmd должен компилироваться нормально.

    <h3><a name="2.11">2.11. Я получаю предупреждение компилируя elkscmd</a></h3>
	Предупреждение такого типа может появляться при построении elkscmd:
	<pre>
	
	    ld86: warning: _utmpname redefined in file /usr/local/bcc/lib/bcc/i86/libc.a(utnt.o); using definition in utent.o
	</pre>
	Это происходит потому что elkscmd содержит правленные версии файлов из стандартной библиотеки C. Однажды эта
	правленная версия была хорошо протестированна, и она будет интегрированна в libs и удалена из Dev86.
	
    <hr>
    	
    <h2>Часть 3 - Использование ELKS</h2>

	<h3><a name="3.1">3.1. Могу я запускать программы скомпилированные bcc из под Linux?</a></h3>
	    Да, при загрузке модуля ядра вы сможете запускать программы ELKS непосредственно. Это делает разработку
	    программ для запуска из-под ELKS более удобной, вы сможете тестировать их на вашей нормальной Linux
	    системе (только они могут не работать под ELKS, если ваша программа использует средства ядра которые пока-что
	    не реализованны)
	    <pre>
	    
		cd /usr/src/linux-86/elksemu
		make module
		insmod binfmt_elks.o
	    </pre>
	Примечание. Вам надо перезапускать 'insmod' каждый раз когда вы перезагружаетесь. Несколько простых программ
	bcc вы можете попробовать в /usr/src/linux-86/tests (такие как версия 'wc'). Если при создании модуля вы
	получаете ошибку, гласящую: "modversions.h: no such file or directory" то вам надо отредактировать Makefile
	и удалить ссылку на этот файл, например:
	<pre>
	
	    MODCFLAGS=-D__KERNEL__ -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer \
    	    -fno-strength-reduce -pipe -m486 -DCPU=486 -DMODULE -DMODVERSIONS
	</pre>
	
	<h3><a name="3.2">3.2. Могу ли я загрузить ELKS из-под DOSEMU?</a></h3>
	    Да. ELKS можно загружать в dosemu 0.63.1.36 запущенной из под Linux 2.0.7, и возможно других комбинаций.
	    Проверьте конфигурацию дисковода в /etc/dosemu.conf, и используйте флаг -A для dos или xdos если необходимо
	    использовать загрузку с дискеты.
	    <pre>
	    
		floppy { device /dev/fd0 threeinch }
	    </pre>

    <hr>
    	
    <h2>Часть 4 - Участие в проекте ELKS</h2>

	<h3><a name="4.1">4.1. Я могу участвовать в проекте ELKS?</a></h3>
    	    Да! Подобно любому другому Open Source проекту, ELKS всегда приветствует добровольцев. Система
	    совсем проста сравнительно с Linux, так что даже люди с небольшим опытом могут внести полезный вклад.
	    ELKS управляется через <a href="http://sourceforge.net">Source Forge</a> - полезный сервис от VA Linux.
	    Для участия в проекте вам необходимо зарегистрироватся в Source Forge.
	    <a href="http://sourceforge.net/project/?group_id=3232">Cтраничка проекта ELKS в Source Forge.</a>
      
	<h3><a name="4.2">4.2. Что нужно cделать?</a></h3>
	    Некоторые идеи о том - что делать могут возникнуть при ознакомлениии с разделами Основные проекты и страницы
	    Ошибок на веб-сайте ELKS. Эти страницы автоматически генерируются из TODO и BUGS файлов в дереве исходников ядра. Кроме
	    ядра имеется большой обьем работы которую должно выполнить для создания дистрибутива linux 8086 который использует
	    ELKS как ядро. Много работы также по портированию имеющихся утилит для работы их под ELKS.
	    
	<h3><a name="4.3">4.3. Что такое CVS?</a></h3>
    	    CVS это система контроля изменений используемая для управления исходным кодом elks и пакета elkscmd.
	    Вы можете использовать CVS для получения самых последних версий исходного кода, просмотра истории изменений,
	    и более опытные разработчики под своими логинами могут выкладывать изменения которые они сделали в исходном коде.
	    <p>ELKS CVS теперь находится в <a href="http://sourceforge.net">Source Forge</a>. Для получения дополнительной
    	    информации по регистрации аккаунта пройдите в раздел CVS
	    <a href="http://sourceforge.net/project/?group_id=3232">на страничке проекта ELKS в Source Forge</a></p>

	<h3><a name="4.4">4.4. Как я могу использовать CVS без логина?</a></h3>
	    Source Forge предоставляет полностью анонимный CVS сервис по умолчанию. Для получения дополнительной
    	    информации пройдите в раздел CVS <a href="http://sourceforge.net/project/?group_id=3232">на страничке проекта ELKS
    	    в Source Forge</a>

    <hr>
    
    This document may be freely distributed as long as this copyright notice is kept intact and any changes or additions are marked with your name<br>
    Copyright (c) 1997-2001<br>
    Maintained by <a href="mailto:ajr@ecs.soton.ac.uk">Al Riddoch</a><br>
    based on pages by <a href="mailto:gabel@physik.uni-kl.de">Steffen Gabel</a><br>
    russian translation by <a href="mailto:roma@orta.com.ua">Roman Festchook</a>
</body>

</html>
